# REQ-plugin_mutate-mutations
###
The plugin shall support **at least** the mutations ROR, AOR, LCR, UOI and ABS.

[[SPC-plugin_mutate_references]] Quote from 2, p.6:
*Offutt et al. [182] extended their 6-selective mutation further
using a similar selection strategy. Based on the type of the Mothra
mutation operators, they divided them into three categories:
statements, operands and expressions. They tried to omit operators
from each class in turn. They discovered that 5 operators from
the operands and expressions class became the key operators.
These 5 operators are ABS, UOI, LCR, AOR and ROR. These
key operators achieved 99.5% mutation score.*

[[SPC-plugin_mutate_references]] Conclusions from 3, p.18:
*The 5 sufficient operators are ABS, whic forces each arithmetic expression to
take on the value 0, a positive value and a negative value, AOR, which replaces
each arithmetic operator with every syntactically legal operator, LCR, which
replaces each logical connector (AND and OR) with several kinds of logical
connectors, ROR, which replaces relational operators with other relational
operators, and UOI, which insert unary operators in front of expressions. It is
interesting to note that this set includes the operators that are required to
satisfy branch and extended branch coverage leading us to believe that extended
branch coverage is in some sense a major part of mutation.*

# SPC-plugin_mutate_mutation_ror
partof: REQ-plugin_mutate-mutations
###

TODO: add requirement.

## Relational Operator Replacement (ROR)
Replace a single operand with another operand.
The operands are:
```cpp
<,<=,>,>=,==,!=
```

# SPC-plugin_mutate_mutation_aor
partof: REQ-plugin_mutate-mutations
###

TODO: add requirement.

## Arithmetic Operator Replacement (AOR)
Replace a single arithmetic operator with another operand.
The operators are:
```cpp
+,-,*,/,%
```

# SPC-plugin_mutate_mutation_lcr
partof: REQ-plugin_mutate-mutations
###

TODO: add requirement.

## Logical Connector Replacement (LCR)
Replace a single operand with another operand.
The operands are:
```cpp
||,&&
```

# SPC-plugin_mutate_mutation_uoi
partof: REQ-plugin_mutate-mutations
###

TODO: add requirement.

## Unary Operator Insertion (UOI)
Insert a single unary operator in expressions where it is possible.

The operands are:
 * Increment: ++x, x++
 * Decrement: −−x, x−−
 * Address: &x
 * Indirection: *x
 * Positive: +x
 * Negative: −x
 * Ones' complement: ~x
 * Logical negation: !x
 * Sizeof: sizeof x, sizeof(type-name)

The cast operator is ignored because it is *probably* not possible to create
any useful mutant with it.
 * Cast: (type-name) cast-expression

Note: The address, indirection and complement operator need to be evaluated to
see how efficient those mutants are.
Are most mutants killed? Compilation errors?

# SPC-plugin_mutate_mutation_abs
partof: REQ-plugin_mutate-mutations
###

TODO: add requirement.

## Absolute Value Insertion (ABS)
Replace an expression.

Example:
```cpp
// original
a = b + c
// the three resulting mutants
a = abs(b) + c
a = -abs(b) + c
a = 0 + c
```

# SPC-plugin_mutate_mutation_cor
partof: REQ-plugin_mutate-mutations
###

TODO: add requirement.

## Conditional Operator Replacement (COR)

This mutation subsumes LCR and all negation mutations generated by UOI.

See [7] p. 2.
_Generally, valid mutations for a conditional expression such as a <op> b,
where <op> denotes one of the logical connectors, include the following:
 * a&&b : Apply the logical connector AND
 * a||b : Apply the logical connector OR
 * a==b : Apply the relational operator a==b
 * a!=b : Apply the relational operator a!=b
 * lhs : Return the value of the left hand side operand
 * rhs : Return the value of the right hand side operand
 * true : Always evaluate to the boolean value true
 * false : Always evaluate to the boolean value false_

a && b:
```
1:  a && b --> false
2:  a && b --> a
3:  a && b --> b
4:  a && b --> a == b

subsumed
5:  a && b --> a || b
6:  a && b --> a != b
7:  a && b --> !(a && b)
8:  a && b --> !a && b
9:  a && b --> a && !b
10: a&& b --> true
```

a || b:
```
1:  a || b --> a != b
2:  a || b --> b
3:  a || b --> a
4:  a || b --> true

subsumed
5:  a || b --> a == b
6:  a || b --> a || b
7:  a || b --> !(a && b)
8:  a || b --> !a && b
9:  a || b --> a && !b
10: a || b --> false
```

# SPC-plugin_mutate_mutation_dcc
partof: REQ-plugin_mutate-mutations
###
A test suite that achieve MC/DC should kill 100% of these mutation type.

TODO: add requirement.

## Decition/Condition Coverage

See [8].

## Undesired Mutant
The mutation abs(0) and abs(0.0) is undesired because it has no semantic effect.
Note though that abs(-0.0) is a separate case.

# SPC-plugin_mutate_mutations_statement_del
partof: REQ-plugin_mutate-mutations
###

The plugin shall remove one statement when generating a _statement deletion_ mutation.

## Statement Deletion (SD)
Delete one statement at a time.

# SPC-plugin_mutate_mutations_statement_del-call_expression
###

The plugin shall remove the specific function call.

Note: How it is removed depend on where it is in the AST.
A function call that is terminated with a `;` should remove the trailing `;`.
In contrast with the initialization list where it should remove the trailing `,`.

# TST-plugin_mutate_statement_del_call_expression
partof: SPC-plugin_mutate-mutations_statement_del-call_expression
###

A mutation is expected to result in valid code.
